"use strict";var Linqer;!function(t){class e{constructor(t){n(t),this._src=t;const e=t[Symbol.iterator];this._generator=e?e.bind(t):t,this._useQuickSort=void 0===t._useQuickSort||t._useQuickSort,this._canSeek=!1,this._count=null,this._tryGetAt=null,this._wasIterated=!1}static from(t){return t instanceof e?t:new e(t)}[Symbol.iterator](){return this._wasIterated=!0,this._generator()}static empty(){const t=new e([]);return t._count=()=>0,t._tryGetAt=t=>null,t._canSeek=!0,t}static range(t,n){const r=new e((function*(){for(let e=0;e<n;e++)yield t+e}));return r._count=()=>n,r._tryGetAt=e=>e>=0&&e<n?{value:t+e}:null,r._canSeek=!0,r}static repeat(t,n){const r=new e((function*(){for(let e=0;e<n;e++)yield t}));return r._count=()=>n,r._tryGetAt=e=>e>=0&&e<n?{value:t}:null,r._canSeek=!0,r}concat(t){n(t);const r=this,o=new e((function*(){for(const t of r)yield t;for(const n of e.from(t))yield n})),u=e.from(t);return o._count=()=>r.count()+u.count(),s(this),s(u),o._canSeek=r._canSeek&&u._canSeek,r._canSeek&&(o._tryGetAt=t=>r._tryGetAt(t)||u._tryGetAt(t-r.count())),o}count(){return u(this),this._count()}distinct(n=t.EqualityComparer.default){const r=this,o=n===t.EqualityComparer.default?function*(){const t=new Set;for(const e of r){const n=t.size;t.add(e),n<t.size&&(yield e)}}:function*(){const t=[];for(const e of r){let r=!0;for(const o of t)if(n(e,o)){r=!1;break}r&&(yield e),t.push(e)}};return new e(o)}elementAt(t){s(this);const e=this._tryGetAt(t);if(!e)throw new Error("Index out of range");return e.value}elementAtOrDefault(t){s(this);const e=this._tryGetAt(t);if(e)return e.value}first(){return this.elementAt(0)}firstOrDefault(){return this.elementAtOrDefault(0)}last(){if(s(this),!this._canSeek){let t=null,e=!1;for(const n of this)t=n,e=!0;if(e)return t;throw new Error("The enumeration is empty")}const t=this.count();return this.elementAt(t-1)}lastOrDefault(){if(s(this),!this._canSeek){let t=void 0;for(const e of this)t=e;return t}const t=this.count();return this.elementAtOrDefault(t-1)}stats(e){e?r(e):e=t._defaultComparer;const n={count:0,min:void 0,max:void 0};for(const t of this)(void 0===n.min||e(t,n.min)<0)&&(n.min=t),(void 0===n.max||e(t,n.max)>0)&&(n.max=t),n.count++;return n}min(t){const e=this.stats(t);return 0===e.count?void 0:e.min}max(t){const e=this.stats(t);return 0===e.count?void 0:e.max}select(t){r(t);const n=this,o=new e((function*(){let e=0;for(const r of n)yield t(r,e),e++}));return u(this),o._count=this._count,s(n),o._canSeek=n._canSeek,o._tryGetAt=e=>{const r=n._tryGetAt(e);return r?{value:t(r.value)}:r},o}skip(t){const n=this,r=new e((function*(){let e=t;for(const t of n)e>0?e--:yield t}));return r._count=()=>Math.max(0,n.count()-t),s(this),r._canSeek=this._canSeek,r._tryGetAt=e=>n._tryGetAt(e+t),r}sum(){const t=this.sumAndCount();return 0===t.count?void 0:t.sum}sumAndCount(){const t={count:0,sum:0};for(const e of this)t.sum=0===t.count?o(e):t.sum+o(e),t.count++;return t}take(t){const n=this,r=new e((function*(){let e=t;for(const t of n)if(e>0&&(yield t,e--),e<=0)break}));return r._count=()=>Math.min(t,n.count()),s(this),r._canSeek=n._canSeek,n._canSeek&&(r._tryGetAt=e=>e>=t?null:n._tryGetAt(e)),r}toArray(){return Array.from(this)}toList(){return s(this),this._canSeek?this:e.from(Array.from(this))}where(t){r(t);const n=this;return new e((function*(){let e=0;for(const r of n)t(r,e)&&(yield r),e++}))}}function n(t){if(t){if(t[Symbol.iterator])return;if("function"==typeof t&&"GeneratorFunction"===t.constructor.name)return}throw new Error("the argument must be iterable!")}function r(t){if(!t||"function"!=typeof t)throw new Error("the argument needs to be a function!")}function o(t){return"number"==typeof t?t:Number.NaN}function u(t){if(t._count)return;const e=t._src;"function"==typeof e||"number"!=typeof e.length?"number"!=typeof e.size?t._count=()=>{let e=0;for(const n of t)e++;return e}:t._count=()=>e.size:t._count=()=>e.length}function s(t){if(t._tryGetAt)return;if(t._canSeek=!0,"string"==typeof t._src)return void(t._tryGetAt=e=>e<t._src.length?{value:t._src.charAt(e)}:null);if(Array.isArray(t._src))return void(t._tryGetAt=e=>e>=0&&e<t._src.length?{value:t._src[e]}:null);const e=t._src;"function"==typeof t._src||"number"!=typeof e.length?(t._canSeek=!1,t._tryGetAt=e=>{let n=0;for(const r of t){if(e===n)return{value:r};n++}return null}):t._tryGetAt=t=>t<e.length&&void 0!==e[t]?{value:e[t]}:null}t.Enumerable=e,t._ensureIterable=n,t._ensureFunction=r,t._toArray=function(t){return t?Array.isArray(t)?t:Array.from(t):[]},t._ensureInternalCount=u,t._ensureInternalTryGetAt=s,t._defaultComparer=(t,e)=>t>e?1:t<e?-1:0,t.EqualityComparer={default:(t,e)=>t==e,exact:(t,e)=>t===e}}(Linqer||(Linqer={})),function(t){t.Enumerable.prototype.aggregate=function(e,n){t._ensureFunction(n);for(const t of this)e=n(e,t);return e},t.Enumerable.prototype.all=function(e){return t._ensureFunction(e),!this.any(t=>!e(t))},t.Enumerable.prototype.any=function(e){t._ensureFunction(e);let n=0;for(const t of this){if(e(t,n))return!0;n++}return!1},t.Enumerable.prototype.append=function(t){return this.concat([t])},t.Enumerable.prototype.average=function(){const t=this.sumAndCount();return 0===t.count?void 0:t.sum/t.count},t.Enumerable.prototype.asEnumerable=function(){return this},t.Enumerable.prototype.cast=function(t){const e="string"==typeof t?e=>typeof e===t:e=>e instanceof t;return this.select(n=>{if(!e(n))throw new Error(n+" not of type "+t);return n})},t.Enumerable.prototype.contains=function(e,n=t.EqualityComparer.default){return t._ensureFunction(n),this.any(t=>n(t,e))},t.Enumerable.prototype.defaultIfEmpty=function(){throw new Error("defaultIfEmpty not implemented for Javascript")},t.Enumerable.prototype.except=function(e,n=t.EqualityComparer.default){t._ensureIterable(e);const r=this,o=n===t.EqualityComparer.default?function*(){const n=t.Enumerable.from(e).toSet();for(const t of r)n.has(t)||(yield t)}:function*(){const o=t._toArray(e);for(const t of r){let e=!0;for(const r of o)if(n(t,r)){e=!1;break}e&&(yield t)}};return new t.Enumerable(o)},t.Enumerable.prototype.intersect=function(e,n=t.EqualityComparer.default){t._ensureIterable(e);const r=this,o=n===t.EqualityComparer.default?function*(){const n=new Set(t.Enumerable.from(e));for(const t of r)n.has(t)&&(yield t)}:function*(){const o=t._toArray(e);for(const t of r){let e=!0;for(const r of o)if(n(t,r)){e=!1;break}e||(yield t)}};return new t.Enumerable(o)},t.Enumerable.prototype.longCount=function(){return this.count()},t.Enumerable.prototype.ofType=function(t){const e="string"==typeof t?e=>typeof e===t:e=>e instanceof t;return this.where(e)},t.Enumerable.prototype.prepend=function(e){return new t.Enumerable([e]).concat(this)},t.Enumerable.prototype.reverse=function(){t._ensureInternalTryGetAt(this);const e=this,n=this._canSeek?function*(){for(let t=e.count()-1;t>=0;t--)yield e.elementAt(t)}:function*(){const n=t._toArray(e);for(let t=n.length-1;t>=0;t--)yield n[t]},r=new t.Enumerable(n);if(t._ensureInternalCount(this),r._count=this._count,t._ensureInternalTryGetAt(this),this._canSeek){const t=this;r._tryGetAt=e=>t._tryGetAt(t.count()-e-1)}return r},t.Enumerable.prototype.selectMany=function(e){void 0!==e?t._ensureFunction(e):e=t=>t;const n=this;return new t.Enumerable((function*(){let r=0;for(const o of n){t._ensureIterable(o);for(const t of e(o,r))yield t;r++}}))},t.Enumerable.prototype.sequenceEqual=function(e,n=t.EqualityComparer.default){t._ensureIterable(e),t._ensureFunction(n);const r=this[Symbol.iterator](),o=t.Enumerable.from(e)[Symbol.iterator]();let u=!1;do{const t=r.next(),e=o.next();if(!(t.done&&e.done||!t.done&&!e.done&&n(t.value,e.value)))return!1;u=!!t.done}while(!u);return!0},t.Enumerable.prototype.single=function(){const t=this[Symbol.iterator]();let e=t.next();if(e.done)throw new Error("Sequence contains no elements");const n=e.value;if(e=t.next(),!e.done)throw new Error("Sequence contains more than one element");return n},t.Enumerable.prototype.singleOrDefault=function(){const t=this[Symbol.iterator]();let e=t.next();if(e.done)return;const n=e.value;if(e=t.next(),!e.done)throw new Error("Sequence contains more than one element");return n},t.Enumerable.prototype.skipLast=function(e){const n=this,r=new t.Enumerable((function*(){let t=e;const r=Array(t);let o=0,u=0;for(const e of n){const n=r[o-u];r[o-u]=e,o++,o-u>=t&&(u+=t),o>t&&(yield n)}r.length=0}));return r._count=()=>Math.max(0,n.count()-e),t._ensureInternalTryGetAt(this),r._canSeek=this._canSeek,this._canSeek&&(r._tryGetAt=t=>t>=r.count()?null:n._tryGetAt(t)),r},t.Enumerable.prototype.skipWhile=function(e){t._ensureFunction(e);const n=this;let r=!0;return new t.Enumerable((function*(){let t=0;for(const o of n)r&&!e(o,t)&&(r=!1),r||(yield o),t++}))},t.Enumerable.prototype.takeLast=function(e){t._ensureInternalTryGetAt(this);const n=this,r=this._canSeek?function*(){let t=e;const r=n.count();for(let e=r-t;e<r;e++)yield n.elementAt(e)}:function*(){let t=e,r=0;const o=Array(t);for(const e of n)o[r%t]=e,r++;for(let e=0;e<t&&e<r;e++)yield o[(r+e)%t]},o=new t.Enumerable(r);return o._count=()=>Math.min(e,n.count()),o._canSeek=n._canSeek,n._canSeek&&(o._tryGetAt=t=>t<0||t>=o.count()?null:n._tryGetAt(n.count()-e+t)),o},t.Enumerable.prototype.takeWhile=function(e){t._ensureFunction(e);const n=this;return new t.Enumerable((function*(){let t=0;for(const r of n){if(!e(r,t))break;yield r,t++}}))},t.Enumerable.prototype.toDictionary=function(){throw new Error("use toMap or toObject instead of toDictionary")},t.Enumerable.prototype.toMap=function(e,n=(t=>t)){t._ensureFunction(e),t._ensureFunction(n);const r=new Map;let o=0;for(const t of this)r.set(e(t,o),n(t,o)),o++;return r},t.Enumerable.prototype.toObject=function(e,n=(t=>t)){t._ensureFunction(e),t._ensureFunction(n);const r={};let o=0;for(const t of this)r[e(t,o)]=n(t),o++;return r},t.Enumerable.prototype.toHashSet=function(){throw new Error("use toSet instead of toHashSet")},t.Enumerable.prototype.toSet=function(){const t=new Set;for(const e of this)t.add(e);return t},t.Enumerable.prototype.union=function(e,n=t.EqualityComparer.default){return t._ensureIterable(e),this.concat(e).distinct(n)},t.Enumerable.prototype.zip=function(e,n){t._ensureIterable(e),n?t._ensureFunction(n):n=(t,e)=>[t,e];const r=this;return new t.Enumerable((function*(){let o=0;const u=r[Symbol.iterator](),s=t.Enumerable.from(e)[Symbol.iterator]();let i=!1;do{const t=u.next(),e=s.next();i=!(!t.done&&!e.done),i||(yield n(t.value,e.value,o)),o++}while(!i)}))}}(Linqer||(Linqer={})),function(t){t.Enumerable.prototype.groupBy=function(n){!function(t){if(!t||"function"!=typeof t)throw new Error("the argument needs to be a function!")}(n);const r=this;return new t.Enumerable((function*(){const t=new Map;let o=0;for(const e of r){const r=n(e,o),u=t.get(r);u?u.push(e):t.set(r,[e]),o++}for(const[n,r]of t){const t=new e(r,n);yield t}}))},t.Enumerable.prototype.groupJoin=function(e,r,o,u,s=t.EqualityComparer.default){const i=this,c=s===t.EqualityComparer.default?function*(){const s=new t.Enumerable(e).groupBy(o).toMap(t=>t.key,t=>t);let c=0;for(const t of i){const e=n(s.get(r(t,c)));yield u(t,e),c++}}:function*(){let n=0;for(const c of i){const i=[];let a=0;for(const u of t.Enumerable.from(e))s(r(c,n),o(u,a))&&i.push(u),a++;yield u(c,i),n++}};return new t.Enumerable(c)},t.Enumerable.prototype.join=function(e,n,r,o,u=t.EqualityComparer.default){const s=this,i=u===t.EqualityComparer.default?function*(){const u=new t.Enumerable(e).groupBy(r).toMap(t=>t.key,t=>t);let i=0;for(const t of s){const e=u.get(n(t,i));if(e)for(const n of e)yield o(t,n);i++}}:function*(){let i=0;for(const c of s){let s=0;for(const a of t.Enumerable.from(e))u(n(c,i),r(a,s))&&(yield o(c,a)),s++;i++}};return new t.Enumerable(i)},t.Enumerable.prototype.toLookup=function(){throw new Error("use groupBy instead of toLookup")};class e extends t.Enumerable{constructor(t,e){super(t),this.key=e}}function n(t){return t?Array.isArray(t)?t:Array.from(t):[]}t.GroupEnumerable=e}(Linqer||(Linqer={})),function(t){let e;t.Enumerable.prototype.orderBy=function(t){return t?r(t):t=t=>t,new n(this,t,!0)},t.Enumerable.prototype.orderByDescending=function(t){return t?r(t):t=t=>t,new n(this,t,!1)},t.Enumerable.prototype.useQuickSort=function(){return this._useQuickSort=!0,this},t.Enumerable.prototype.useBrowserSort=function(){return this._useQuickSort=!1,this},function(t){t[t.skip=0]="skip",t[t.skipLast=1]="skipLast",t[t.take=2]="take",t[t.takeLast=3]="takeLast"}(e||(e={}));class n extends t.Enumerable{constructor(e,n,r=!0){super(e),this._keySelectors=[],this._restrictions=[],n&&this._keySelectors.push({keySelector:n,ascending:r});const o=this;this._generator=function*(){const e=Array.from(this._src),{startIndex:n,endIndex:r}=this.getStartAndEndIndexes(o._restrictions,e.length);if(n<r){(this._useQuickSort&&this._restrictions.length?(e,o)=>function(e,n,r,o=t._defaultComparer,s=0,i=Number.MAX_SAFE_INTEGER){if(!e.length)return e;const c=[];c.push([n,r]);let a=0;for(;a<c.length;){[n,r]=c[a];const t=u(e,n,r,o);n<t-1&&t-1>=s&&c.push([n,t-1]),t<r&&t<i&&c.push([t,r]),a++}return e}(e,0,e.length-1,o,n,r):(t,e)=>t.sort(e))(e,this.generateSortFunc(o._keySelectors));for(let t=n;t<r;t++)yield e[t]}},this._count=()=>{const e=t.Enumerable.from(o._src).count(),{startIndex:n,endIndex:r}=this.getStartAndEndIndexes(o._restrictions,e);return r-n}}generateSortFunc(t){const e=t.map(t=>{const e=t.keySelector,n=(t,n)=>{const r=e(t),o=e(n);return r>o?1:r<o?-1:0};return t.ascending?n:(t,e)=>-n(t,e)});return(t,n)=>{for(const r of e){const e=r(t,n);if(e)return e}return 0}}getStartAndEndIndexes(t,n){let r=0,o=n;for(const n of t)switch(n.type){case e.take:o=Math.min(o,r+n.nr);break;case e.skip:r=Math.min(o,r+n.nr);break;case e.takeLast:r=Math.max(r,o-n.nr);break;case e.skipLast:o=Math.max(r,o-n.nr)}return{startIndex:r,endIndex:o}}thenBy(t){return this._keySelectors.push({keySelector:t,ascending:!0}),this}thenByDescending(t){return this._keySelectors.push({keySelector:t,ascending:!1}),this}take(t){return this._restrictions.push({type:e.take,nr:t}),this}takeLast(t){return this._restrictions.push({type:e.takeLast,nr:t}),this}skip(t){return this._restrictions.push({type:e.skip,nr:t}),this}skipLast(t){return this._restrictions.push({type:e.skipLast,nr:t}),this}}function r(t){if(!t||"function"!=typeof t)throw new Error("the argument needs to be a function!")}function o(t,e,n){const r=t[e];t[e]=t[n],t[n]=r}function u(t,e,n,r){const u=t[n+e>>1];for(;e<=n;){for(;r(t[e],u)<0;)e++;for(;r(t[n],u)>0;)n--;if(e<n)o(t,e,n),e++,n--;else if(e===n)return e+1}return e}t.OrderedEnumerable=n}(Linqer||(Linqer={})),"undefined"!=typeof module&&(module.exports={Linqer:Linqer});