"use strict";var Linqer;!function(t){class e{constructor(t){n(t),this._src=t;const e=t[Symbol.iterator];this._generator=e?e.bind(t):t,this._useQuickSort=void 0===t._useQuickSort||t._useQuickSort,this._canSeek=!1,this._count=null,this._tryGetAt=null,this._wasIterated=!1}static from(t){return t instanceof e?t:new e(t)}[Symbol.iterator](){return this._wasIterated=!0,this._generator()}static empty(){const t=new e([]);return t._count=()=>0,t._tryGetAt=t=>null,t._canSeek=!0,t}static range(t,n){const r=new e((function*(){for(let e=0;e<n;e++)yield t+e}));return r._count=()=>n,r._tryGetAt=e=>e>=0&&e<n?{value:t+e}:null,r._canSeek=!0,r}static repeat(t,n){const r=new e((function*(){for(let e=0;e<n;e++)yield t}));return r._count=()=>n,r._tryGetAt=e=>e>=0&&e<n?{value:t}:null,r._canSeek=!0,r}get length(){if(s(this),!this._canSeek)throw new Error("Calling length on this enumerable will iterate it. Use count()");return this.count()}concat(t){n(t);const r=this,o=new e((function*(){for(const t of r)yield t;for(const n of e.from(t))yield n})),u=e.from(t);return o._count=()=>r.count()+u.count(),s(this),s(u),o._canSeek=r._canSeek&&u._canSeek,r._canSeek&&(o._tryGetAt=t=>r._tryGetAt(t)||u._tryGetAt(t-r.count())),o}count(){return u(this),this._count()}distinct(n=t.EqualityComparer.default){const r=this,o=n===t.EqualityComparer.default?function*(){const t=new Set;for(const e of r){const n=t.size;t.add(e),n<t.size&&(yield e)}}:function*(){const t=[];for(const e of r){let r=!0;for(let o=0;o<t.length;o++)if(n(e,t[o])){r=!1;break}r&&(yield e),t.push(e)}};return new e(o)}elementAt(t){s(this);const e=this._tryGetAt(t);if(!e)throw new Error("Index out of range");return e.value}elementAtOrDefault(t){s(this);const e=this._tryGetAt(t);if(e)return e.value}first(){return this.elementAt(0)}firstOrDefault(){return this.elementAtOrDefault(0)}last(){if(s(this),!this._canSeek){let t=null,e=!1;for(const n of this)t=n,e=!0;if(e)return t;throw new Error("The enumeration is empty")}const t=this.count();return this.elementAt(t-1)}lastOrDefault(){if(s(this),!this._canSeek){let t=void 0;for(const e of this)t=e;return t}const t=this.count();return this.elementAtOrDefault(t-1)}stats(e){e?r(e):e=t._defaultComparer;const n={count:0,min:void 0,max:void 0};for(const t of this)(void 0===n.min||e(t,n.min)<0)&&(n.min=t),(void 0===n.max||e(t,n.max)>0)&&(n.max=t),n.count++;return n}min(t){const e=this.stats(t);return 0===e.count?void 0:e.min}max(t){const e=this.stats(t);return 0===e.count?void 0:e.max}select(t){r(t);const n=this,o=new e((function*(){let e=0;for(const r of n)yield t(r,e),e++}));return u(this),o._count=this._count,s(n),o._canSeek=n._canSeek,o._tryGetAt=e=>{const r=n._tryGetAt(e);return r?{value:t(r.value)}:r},o}skip(t){const n=this,r=new e((function*(){let e=t;for(const t of n)e>0?e--:yield t}));return r._count=()=>Math.max(0,n.count()-t),s(this),r._canSeek=this._canSeek,r._tryGetAt=e=>n._tryGetAt(e+t),r}splice(t,e,...n){return this.take(t).concat(n).concat(this.skip(t+e))}sum(){const t=this.sumAndCount();return 0===t.count?void 0:t.sum}sumAndCount(){const t={count:0,sum:0};for(const e of this)t.sum=0===t.count?o(e):t.sum+o(e),t.count++;return t}take(t){const n=this,r=new e((function*(){let e=t;for(const t of n)if(e>0&&(yield t,e--),e<=0)break}));return r._count=()=>Math.min(t,n.count()),s(this),r._canSeek=n._canSeek,n._canSeek&&(r._tryGetAt=e=>e>=t?null:n._tryGetAt(e)),r}toArray(){var t;if(s(this),this._canSeek){const e=new Array(this.count());for(let n=0;n<e.length;n++)e[n]=null===(t=this._tryGetAt(n))||void 0===t?void 0:t.value;return e}let e=0;const n=[];for(const t of this)e===n.length&&(n.length+=64),n[e]=t,e++;return n.length=e,n}toList(){return s(this),this._canSeek?this:e.from(this.toArray())}where(t){r(t);const n=this;return new e((function*(){let e=0;for(const r of n)t(r,e)&&(yield r),e++}))}}function n(t){if(t){if(t[Symbol.iterator])return;if("function"==typeof t&&"GeneratorFunction"===t.constructor.name)return}throw new Error("the argument must be iterable!")}function r(t){if(!t||"function"!=typeof t)throw new Error("the argument needs to be a function!")}function o(t){return"number"==typeof t?t:Number.NaN}function u(t){if(t._count)return;if(t._src instanceof e){const e=t._src;return u(e),void(t._count=()=>e._count())}const n=t._src;"function"==typeof n||"number"!=typeof n.length?"number"!=typeof n.size?t._count=()=>{let e=0;for(const n of t)e++;return e}:t._count=()=>n.size:t._count=()=>n.length}function s(t){if(t._tryGetAt)return;if(t._canSeek=!0,t._src instanceof e){const e=t._src;return s(e),t._tryGetAt=t=>e._tryGetAt(t),void(t._canSeek=e._canSeek)}if("string"==typeof t._src)return void(t._tryGetAt=e=>e<t._src.length?{value:t._src.charAt(e)}:null);if(Array.isArray(t._src))return void(t._tryGetAt=e=>e>=0&&e<t._src.length?{value:t._src[e]}:null);const n=t._src;"function"==typeof t._src||"number"!=typeof n.length?(t._canSeek=!1,t._tryGetAt=e=>{let n=0;for(const r of t){if(e===n)return{value:r};n++}return null}):t._tryGetAt=t=>t<n.length&&void 0!==n[t]?{value:n[t]}:null}t.Enumerable=e,t._ensureIterable=n,t._ensureFunction=r,t._toArray=function(t){return t?Array.isArray(t)?t:Array.from(t):[]},t._ensureInternalCount=u,t._ensureInternalTryGetAt=s,t._defaultComparer=(t,e)=>t>e?1:t<e?-1:0,t.EqualityComparer={default:(t,e)=>t==e,exact:(t,e)=>t===e}}(Linqer||(Linqer={})),function(t){t.Enumerable.prototype.aggregate=function(e,n){t._ensureFunction(n);for(const t of this)e=n(e,t);return e},t.Enumerable.prototype.all=function(e){return t._ensureFunction(e),!this.any(t=>!e(t))},t.Enumerable.prototype.any=function(e){t._ensureFunction(e);let n=0;for(const t of this){if(e(t,n))return!0;n++}return!1},t.Enumerable.prototype.append=function(t){return this.concat([t])},t.Enumerable.prototype.average=function(){const t=this.sumAndCount();return 0===t.count?void 0:t.sum/t.count},t.Enumerable.prototype.asEnumerable=function(){return this},t.Enumerable.prototype.cast=function(t){const e="string"==typeof t?e=>typeof e===t:e=>e instanceof t;return this.select(n=>{if(!e(n))throw new Error(n+" not of type "+t);return n})},t.Enumerable.prototype.contains=function(e,n=t.EqualityComparer.default){return t._ensureFunction(n),this.any(t=>n(t,e))},t.Enumerable.prototype.defaultIfEmpty=function(){throw new Error("defaultIfEmpty not implemented for Javascript")},t.Enumerable.prototype.except=function(e,n=t.EqualityComparer.default){t._ensureIterable(e);const r=this,o=n===t.EqualityComparer.default?function*(){const n=t.Enumerable.from(e).toSet();for(const t of r)n.has(t)||(yield t)}:function*(){const o=t._toArray(e);for(const t of r){let e=!0;for(let r=0;r<o.length;r++)if(n(t,o[r])){e=!1;break}e&&(yield t)}};return new t.Enumerable(o)},t.Enumerable.prototype.intersect=function(e,n=t.EqualityComparer.default){t._ensureIterable(e);const r=this,o=n===t.EqualityComparer.default?function*(){const n=new Set(t.Enumerable.from(e));for(const t of r)n.has(t)&&(yield t)}:function*(){const o=t._toArray(e);for(const t of r){let e=!0;for(let r=0;r<o.length;r++)if(n(t,o[r])){e=!1;break}e||(yield t)}};return new t.Enumerable(o)},t.Enumerable.prototype.longCount=function(){return this.count()},t.Enumerable.prototype.ofType=function(t){const e="string"==typeof t?e=>typeof e===t:e=>e instanceof t;return this.where(e)},t.Enumerable.prototype.prepend=function(e){return new t.Enumerable([e]).concat(this)},t.Enumerable.prototype.reverse=function(){t._ensureInternalTryGetAt(this);const e=this,n=this._canSeek?function*(){for(let t=e.count()-1;t>=0;t--)yield e.elementAt(t)}:function*(){const t=e.toArray();for(let e=t.length-1;e>=0;e--)yield t[e]},r=new t.Enumerable(n);if(t._ensureInternalCount(this),r._count=this._count,t._ensureInternalTryGetAt(this),this._canSeek){const t=this;r._canSeek=!0,r._tryGetAt=e=>t._tryGetAt(t.count()-e-1)}return r},t.Enumerable.prototype.selectMany=function(e){void 0!==e?t._ensureFunction(e):e=t=>t;const n=this;return new t.Enumerable((function*(){let r=0;for(const o of n){const n=e(o,r);t._ensureIterable(n);for(const t of n)yield t;r++}}))},t.Enumerable.prototype.sequenceEqual=function(e,n=t.EqualityComparer.default){t._ensureIterable(e),t._ensureFunction(n);const r=this[Symbol.iterator](),o=t.Enumerable.from(e)[Symbol.iterator]();let u=!1;do{const t=r.next(),e=o.next();if(!(t.done&&e.done||!t.done&&!e.done&&n(t.value,e.value)))return!1;u=!!t.done}while(!u);return!0},t.Enumerable.prototype.single=function(){const t=this[Symbol.iterator]();let e=t.next();if(e.done)throw new Error("Sequence contains no elements");const n=e.value;if(e=t.next(),!e.done)throw new Error("Sequence contains more than one element");return n},t.Enumerable.prototype.singleOrDefault=function(){const t=this[Symbol.iterator]();let e=t.next();if(e.done)return;const n=e.value;if(e=t.next(),!e.done)throw new Error("Sequence contains more than one element");return n},t.Enumerable.prototype.slice=function(t=0,e){let n=this;return void 0!==e&&e>=0&&(t||0)<0&&(n=n.toList(),t=n.count()+t),0!==t&&(n=t>0?n.skip(t):n.takeLast(-t)),void 0!==e&&(n=e>=0?n.take(e-t):n.skipLast(-e)),n},t.Enumerable.prototype.skipLast=function(e){const n=this,r=new t.Enumerable((function*(){let t=e;const r=Array(t);let o=0,u=0;for(const e of n){const n=r[o-u];r[o-u]=e,o++,o-u>=t&&(u+=t),o>t&&(yield n)}r.length=0}));return r._count=()=>Math.max(0,n.count()-e),t._ensureInternalTryGetAt(this),r._canSeek=this._canSeek,this._canSeek&&(r._tryGetAt=t=>t>=r.count()?null:n._tryGetAt(t)),r},t.Enumerable.prototype.skipWhile=function(e){t._ensureFunction(e);const n=this;let r=!0;return new t.Enumerable((function*(){let t=0;for(const o of n)r&&!e(o,t)&&(r=!1),r||(yield o),t++}))},t.Enumerable.prototype.takeLast=function(e){t._ensureInternalTryGetAt(this);const n=this,r=this._canSeek?function*(){let t=e;const r=n.count();for(let e=r-t;e<r;e++)yield n.elementAt(e)}:function*(){let t=e,r=0;const o=Array(t);for(const e of n)o[r%t]=e,r++;for(let e=0;e<t&&e<r;e++)yield o[(r+e)%t]},o=new t.Enumerable(r);return o._count=()=>Math.min(e,n.count()),o._canSeek=n._canSeek,n._canSeek&&(o._tryGetAt=t=>t<0||t>=o.count()?null:n._tryGetAt(n.count()-e+t)),o},t.Enumerable.prototype.takeWhile=function(e){t._ensureFunction(e);const n=this;return new t.Enumerable((function*(){let t=0;for(const r of n){if(!e(r,t))break;yield r,t++}}))},t.Enumerable.prototype.toDictionary=function(){throw new Error("use toMap or toObject instead of toDictionary")},t.Enumerable.prototype.toMap=function(e,n=(t=>t)){t._ensureFunction(e),t._ensureFunction(n);const r=new Map;let o=0;for(const t of this)r.set(e(t,o),n(t,o)),o++;return r},t.Enumerable.prototype.toObject=function(e,n=(t=>t)){t._ensureFunction(e),t._ensureFunction(n);const r={};let o=0;for(const t of this)r[e(t,o)]=n(t),o++;return r},t.Enumerable.prototype.toHashSet=function(){throw new Error("use toSet instead of toHashSet")},t.Enumerable.prototype.toSet=function(){const t=new Set;for(const e of this)t.add(e);return t},t.Enumerable.prototype.union=function(e,n=t.EqualityComparer.default){return t._ensureIterable(e),this.concat(e).distinct(n)},t.Enumerable.prototype.zip=function(e,n){t._ensureIterable(e),n?t._ensureFunction(n):n=(t,e)=>[t,e];const r=this;return new t.Enumerable((function*(){let o=0;const u=r[Symbol.iterator](),s=t.Enumerable.from(e)[Symbol.iterator]();let i=!1;do{const t=u.next(),e=s.next();i=!(!t.done&&!e.done),i||(yield n(t.value,e.value,o)),o++}while(!i)}))}}(Linqer||(Linqer={})),function(t){t.Enumerable.prototype.groupBy=function(n){t._ensureFunction(n);const r=this;return new t.Enumerable((function*(){const t=new Map;let o=0;for(const e of r){const r=n(e,o),u=t.get(r);u?u.push(e):t.set(r,[e]),o++}for(const[n,r]of t){const t=new e(r,n);yield t}}))},t.Enumerable.prototype.groupJoin=function(e,n,r,o,u=t.EqualityComparer.default){const s=this,i=u===t.EqualityComparer.default?function*(){const u=new t.Enumerable(e).groupBy(r).toMap(t=>t.key,t=>t);let i=0;for(const e of s){const r=t._toArray(u.get(n(e,i)));yield o(e,r),i++}}:function*(){let i=0;for(const c of s){const s=[];let a=0;for(const o of t.Enumerable.from(e))u(n(c,i),r(o,a))&&s.push(o),a++;yield o(c,s),i++}};return new t.Enumerable(i)},t.Enumerable.prototype.join=function(e,n,r,o,u=t.EqualityComparer.default){const s=this,i=u===t.EqualityComparer.default?function*(){const u=new t.Enumerable(e).groupBy(r).toMap(t=>t.key,t=>t);let i=0;for(const t of s){const e=u.get(n(t,i));if(e)for(const n of e)yield o(t,n);i++}}:function*(){let i=0;for(const c of s){let s=0;for(const a of t.Enumerable.from(e))u(n(c,i),r(a,s))&&(yield o(c,a)),s++;i++}};return new t.Enumerable(i)},t.Enumerable.prototype.toLookup=function(){throw new Error("use groupBy instead of toLookup")};class e extends t.Enumerable{constructor(t,e){super(t),this.key=e}}t.GroupEnumerable=e}(Linqer||(Linqer={})),function(t){let e;t.Enumerable.prototype.orderBy=function(e){return e?t._ensureFunction(e):e=t=>t,new n(this,e,!0)},t.Enumerable.prototype.orderByDescending=function(e){return e?t._ensureFunction(e):e=t=>t,new n(this,e,!1)},t.Enumerable.prototype.useQuickSort=function(){return this._useQuickSort=!0,this},t.Enumerable.prototype.useBrowserSort=function(){return this._useQuickSort=!1,this},t.Enumerable.sort=function(e,n=t._defaultComparer){return s(e,0,e.length-1,n,0,Number.MAX_SAFE_INTEGER),e},function(t){t[t.skip=0]="skip",t[t.skipLast=1]="skipLast",t[t.take=2]="take",t[t.takeLast=3]="takeLast"}(e||(e={}));class n extends t.Enumerable{constructor(e,n,r=!0){super(e),this._keySelectors=[],this._restrictions=[],n&&this._keySelectors.push({keySelector:n,ascending:r});const o=this;this._generator=function*(){let{startIndex:t,endIndex:e,arr:n}=this.getSortedArray();if(n)for(let r=t;r<e;r++)yield n[r]},this._count=()=>{const e=t.Enumerable.from(o._src).count(),{startIndex:n,endIndex:r}=this.getStartAndEndIndexes(o._restrictions,e);return r-n},this._canSeek=!1,this._tryGetAt=()=>{throw new Error("Ordered enumerables cannot seek")}}getSortedArray(){const e=this;let n,r,o=null;const u=e._src;if(t._ensureInternalTryGetAt(u),u._canSeek?({startIndex:n,endIndex:r}=e.getStartAndEndIndexes(e._restrictions,u.count())):(o=Array.from(e._src),({startIndex:n,endIndex:r}=e.getStartAndEndIndexes(e._restrictions,o.length))),n<r){o||(o=Array.from(e._src));return(e._useQuickSort?(t,e)=>s(t,0,t.length-1,e,n,r):(t,e)=>t.sort(e))(o,e.generateSortFunc(e._keySelectors)),{startIndex:n,endIndex:r,arr:o}}return{startIndex:n,endIndex:r,arr:null}}generateSortFunc(t){const e=t.map(t=>{const e=t.keySelector,n=(t,n)=>{const r=e(t),o=e(n);return r>o?1:r<o?-1:0};return t.ascending?n:(t,e)=>-n(t,e)});return 1==e.length?e[0]:(t,n)=>{for(let r=0;r<e.length;r++){const o=e[r](t,n);if(o)return o}return 0}}getStartAndEndIndexes(t,n){let r=0,o=n;for(const n of t)switch(n.type){case e.take:o=Math.min(o,r+n.nr);break;case e.skip:r=Math.min(o,r+n.nr);break;case e.takeLast:r=Math.max(r,o-n.nr);break;case e.skipLast:o=Math.max(r,o-n.nr)}return{startIndex:r,endIndex:o}}thenBy(t){return this._keySelectors.push({keySelector:t,ascending:!0}),this}thenByDescending(t){return this._keySelectors.push({keySelector:t,ascending:!1}),this}take(t){return this._restrictions.push({type:e.take,nr:t}),this}takeLast(t){return this._restrictions.push({type:e.takeLast,nr:t}),this}skip(t){return this._restrictions.push({type:e.skip,nr:t}),this}skipLast(t){return this._restrictions.push({type:e.skipLast,nr:t}),this}toArray(){const{startIndex:t,endIndex:e,arr:n}=this.getSortedArray();return n?n.slice(t,e):[]}toMap(e,n=(t=>t)){t._ensureFunction(e),t._ensureFunction(n);const r=new Map,o=this.toArray();for(let t=0;t<o.length;t++)r.set(e(o[t],t),n(o[t],t));return r}toObject(e,n=(t=>t)){t._ensureFunction(e),t._ensureFunction(n);const r={},o=this.toArray();for(let t=0;t<o.length;t++)r[e(o[t],t)]=n(o[t],t);return r}toSet(){const t=new Set,e=this.toArray();for(let n=0;n<e.length;n++)t.add(e[n]);return t}}t.OrderedEnumerable=n;function r(t,e,n,r){for(let o=e;o<=n;o++){const n=t[o];let u=o-1;for(;u>=e&&r(t[u],n)>0;)t[u+1]=t[u],u--;t[u+1]=n}}function o(t,e,n){const r=t[e];t[e]=t[n],t[n]=r}function u(t,e,n,r){const u=t[n+e>>1];for(;e<=n;){for(;r(t[e],u)<0;)e++;for(;r(t[n],u)>0;)n--;if(e<n)o(t,e,n),e++,n--;else if(e===n)return e+1}return e}function s(e,n,o,s=t._defaultComparer,i=0,c=Number.MAX_SAFE_INTEGER){if(!e.length)return e;const a=[];a.push({left:n,right:o});let l=1;for(;l;){const t=({left:n,right:o}=a[l-1]);if(o-n<64){r(e,n,o,s),l--;continue}const f=u(e,n,o,s);n<f-1&&f-1>=i?(t.right=f-1,f<o&&f<c&&(a[l]={left:f,right:o},l++)):f<o&&f<c?t.left=f:l--}return e}}(Linqer||(Linqer={})),"undefined"!=typeof module&&(module.exports=Linqer);